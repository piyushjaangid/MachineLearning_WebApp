<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Run Your ML Model</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: auto; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; }
        .form-group textarea, .form-group select, .form-group input { width: 100%; padding: 8px; }
        .form-group button { padding: 10px 20px; }
        .result, .status, .preview, .progress { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
        .progress progress { width: 100%; }
        #chart { width: 100%; height: 400px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@9.4.4/lib/browser/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<div class="container">
    <h1>Run Your ML Model</h1>

    <div class="form-group">
        <label for="dataInput">Enter Data (CSV format: first row containing variable names, then variable values)</label>
        <textarea id="dataInput" rows="10" placeholder="Enter data in CSV format"></textarea>
    </div>

    <div class="form-group">
        <button onclick="previewData()">Preview Data</button>
    </div>

    <div class="form-group">
        <label for="dependentVar">Select Dependent Variable</label>
        <select id="dependentVar"></select>
    </div>

    <div class="form-group">
        <label for="independentVars">Select Independent Variables</label>
        <select id="independentVars" multiple></select>
    </div>

    <div class="form-group">
        <label for="problemType">Select Problem Type</label>
        <select id="problemType">
            <option value="classification">Classification</option>
            <option value="regression">Regression</option>
        </select>
    </div>

    <div class="form-group">
        <button onclick="runModel()">Run Model</button>
    </div>

    <div class="progress">
        <progress id="progressBar" value="0" max="100"></progress>
        <span id="progressText">0%</span>
    </div>

    <div class="status" id="status"></div>
    <div class="preview" id="preview"></div>
    <div class="result" id="result"></div>
    <canvas id="chart"></canvas>
</div>

<script>
    function previewData() {
        const dataInput = document.getElementById('dataInput').value;
        displayPreview(dataInput);
    }

    function displayPreview(content) {
        const rows = content.split('\n');
        const previewDiv = document.getElementById('preview');
        previewDiv.innerHTML = `<h2>Preview of Data (First 5 Rows)</h2>`;
        rows.slice(0, 5).forEach(row => {
            previewDiv.innerHTML += `<pre>${row}</pre>`;
        });

        const columns = rows[0].split(',');
        populateDropdowns(columns);
    }

    function populateDropdowns(columns) {
        const dependentVar = document.getElementById('dependentVar');
        const independentVars = document.getElementById('independentVars');
        dependentVar.innerHTML = '';
        independentVars.innerHTML = '';

        columns.forEach(col => {
            const option = document.createElement('option');
            option.value = col;
            option.textContent = col;
            dependentVar.appendChild(option);

            const multiOption = option.cloneNode(true);
            independentVars.appendChild(multiOption);
        });
    }

    function updateProgress(progress) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        progressBar.value = progress;
        progressText.textContent = `${progress}%`;
    }

    function runModel() {
        const statusDiv = document.getElementById('status');
        const dependentVar = document.getElementById('dependentVar').value;
        const independentVars = Array.from(document.getElementById('independentVars').selectedOptions).map(opt => opt.value);
        const problemType = document.getElementById('problemType').value;

        statusDiv.textContent = `Running model...`;
        updateProgress(0);

        const dataInput = document.getElementById('dataInput').value;
        const rows = dataInput.split('\n').map(row => row.split(','));
        const headers = rows[0];
        const data = rows.slice(1).map(row => row.map(cell => parseFloat(cell)));

        const depIndex = headers.indexOf(dependentVar);
        const indIndexes = independentVars.map(v => headers.indexOf(v));

        const X = data.map(row => indIndexes.map(i => row[i]));
        const y = data.map(row => row[depIndex]);

        const algorithms = problemType === 'regression' ? [
            new LinearRegression(),
            new DecisionTreeClassifier(),
            new RandomForestClassifier(),
            new GradientBoostingClassifier(),
            new AdaBoostClassifier()
        ] : [
            new LogisticRegression(),
            new DecisionTreeClassifier(),
            new SVMClassifier(),
            new NaiveBayesClassifier(),
            new KNNClassifier(),
            new RandomForestClassifier(),
            new GradientBoostingClassifier(),
            new AdaBoostClassifier()
        ];

        let progressIncrement = 70 / algorithms.length;
        let progress = 30;

        algorithms.forEach((model, index) => {
            setTimeout(() => {
                model.fit(X, y);
                const yPred = model.predict(X);
                const result = calculateMetrics(y, yPred, problemType);
                displayResult(result, model.constructor.name);

                progress += progressIncrement;
                updateProgress(progress);

                if (index === algorithms.length - 1) {
                    setTimeout(() => {
                        updateProgress(100);
                        statusDiv.textContent = 'Model run successfully';
                    }, 500);
                }
            }, index * 500);
        });
    }

    function displayResult(result, modelName) {
        const resultDiv = document.getElementById('result');
        resultDiv.innerHTML += `
            <h2>${modelName} Results</h2>
            <pre>${JSON.stringify(result, null, 2)}</pre>
            <h3>Evaluation Metrics</h3>
            <p><b>Confusion Matrix:</b> [[${result.confusion_matrix[0][0]}, ${result.confusion_matrix[0][1]}], [${result.confusion_matrix[1][0]}, ${result.confusion_matrix[1][1]}]]</p>
            <p><b>Accuracy:</b> ${result.accuracy} = (TP + TN) / (TP + TN + FP + FN)</p>
            <p><b>Precision:</b> ${result.precision} = TP / (TP + FP)</p>
            <p><b>Recall:</b> ${result.recall} = TP / (TP + FN)</p>
            <p><b>F1 Score:</b> ${result.f1_score} = 2 * (Precision * Recall) / (Precision + Recall)</p>
            <p><b>Specificity:</b> ${result.specificity} = TN / (TN + FP)</p>
            <p><b>LR+:</b> ${result.lr_plus} = Recall / (1 - Specificity)</p>
            <p><b>Odds Ratio:</b> ${result.odds_ratio} = (TP * TN) / (FP * FN)</p>
            <p><b>Prevalence Threshold:</b> ${result.prevalence_threshold} = (sqrt(TP + FN) - sqrt(FP + TN)) / (TP + TN + FP + FN)</p>
        `;

        displayGraph(result.roc_curve, modelName);
    }

    function displayGraph(rocCurve, modelName) {
        const ctx = document.getElementById('chart').getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: rocCurve.map(point => point.fpr),
                datasets: [{
                    label: `${modelName} ROC Curve`,
                    data: rocCurve.map(point => point.tpr),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 2,
                    fill: false
                }]
            },
            options: {
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'False Positive Rate'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'True Positive Rate'
                        }
                    }
                }
            }
        });
    }

    class LinearRegression {
        fit(X, y) {
            X = X.map(row => [1, ...row]);
            const Xt = math.transpose(X);
            const XtX = math.multiply(Xt, X);
            const XtX_inv = math.inv(XtX);
            const XtX_inv_Xt = math.multiply(XtX_inv, Xt);
            this.coef_ = math.multiply(XtX_inv_Xt, y);
        }

        predict(X) {
            X = X.map(row => [1, ...row]);
            return math.multiply(X, this.coef_);
        }
    }

    class LogisticRegression {
        fit(X, y) {
            X = X.map(row => [1, ...row]);
            const sigmoid = z => 1 / (1 + Math.exp(-z));
            this.coef_ = Array(X[0].length).fill(0);
            const learningRate = 0.01;
            const iterations = 1000;

            for (let i = 0; i < iterations; i++) {
                const z = math.multiply(X, this.coef_);
                const h = z.map(sigmoid);
                const gradient = math.multiply(math.transpose(X), math.subtract(h, y));
                this.coef_ = math.subtract(this.coef_, math.multiply(learningRate, gradient));
            }
        }

        predict(X) {
            X = X.map(row => [1, ...row]);
            const z = math.multiply(X, this.coef_);
            const sigmoid = z => 1 / (1 + Math.exp(-z));
            const probs = z.map(sigmoid);
            return probs.map(p => (p >= 0.5 ? 1 : 0));
        }
    }

    class DecisionTreeClassifier {
        fit(X, y) {
            const buildTree = (X, y, depth = 0) => {
                if (depth === 5 || y.every(val => val === y[0])) {
                    return { value: y[0] };
                }

                let bestFeature, bestThreshold, bestGini = Infinity;
                for (let feature = 0; feature < X[0].length; feature++) {
                    const thresholds = [...new Set(X.map(row => row[feature]))];
                    for (const threshold of thresholds) {
                        const [leftX, leftY, rightX, rightY] = this.split(X, y, feature, threshold);
                        const gini = this.giniImpurity(leftY, rightY);
                        if (gini < bestGini) {
                            bestGini = gini;
                            bestFeature = feature;
                            bestThreshold = threshold;
                        }
                    }
                }

                const [leftX, leftY, rightX, rightY] = this.split(X, y, bestFeature, bestThreshold);
                return {
                    feature: bestFeature,
                    threshold: bestThreshold,
                    left: buildTree(leftX, leftY, depth + 1),
                    right: buildTree(rightX, rightY, depth + 1)
                };
            };

            this.tree = buildTree(X, y);
        }

        predict(X) {
            const traverse = (node, row) => {
                if (node.value !== undefined) {
                    return node.value;
                }
                if (row[node.feature] < node.threshold) {
                    return traverse(node.left, row);
                } else {
                    return traverse(node.right, row);
                }
            };

            return X.map(row => traverse(this.tree, row));
        }

        split(X, y, feature, threshold) {
            const leftX = [], leftY = [], rightX = [], rightY = [];
            for (let i = 0; i < X.length; i++) {
                if (X[i][feature] < threshold) {
                    leftX.push(X[i]);
                    leftY.push(y[i]);
                } else {
                    rightX.push(X[i]);
                    rightY.push(y[i]);
                }
            }
            return [leftX, leftY, rightX, rightY];
        }

        giniImpurity(leftY, rightY) {
            const leftSize = leftY.length;
            const rightSize = rightY.length;
            const totalSize = leftSize + rightSize;
            const gini = side => 1 - side.reduce((acc, val) => {
                const p = side.filter(v => v === val).length / side.length;
                return acc + p * p;
            }, 0);
            return (leftSize / totalSize) * gini(leftY) + (rightSize / totalSize) * gini(rightY);
        }
    }

    class SVMClassifier {
        fit(X, y) {
            const C = 1.0;
            const tol = 1e-3;
            const maxPasses = 5;
            const kernel = (x1, x2) => math.dot(x1, x2);

            this.alphas = Array(y.length).fill(0);
            this.b = 0;

            let passes = 0;
            while (passes < maxPasses) {
                let numChangedAlphas = 0;
                for (let i = 0; i < y.length; i++) {
                    const Ei = this.decisionFunction(X[i]) - y[i];
                    if ((y[i] * Ei < -tol && this.alphas[i] < C) || (y[i] * Ei > tol && this.alphas[i] > 0)) {
                        const j = this.randomIndex(i, y.length);
                        const Ej = this.decisionFunction(X[j]) - y[j];
                        const oldAi = this.alphas[i];
                        const oldAj = this.alphas[j];
                        const L = Math.max(0, oldAj - oldAi);
                        const H = Math.min(C, C + oldAj - oldAi);
                        if (L === H) continue;

                        const eta = 2 * kernel(X[i], X[j]) - kernel(X[i], X[i]) - kernel(X[j], X[j]);
                        if (eta >= 0) continue;

                        this.alphas[j] -= y[j] * (Ei - Ej) / eta;
                        this.alphas[j] = Math.min(H, Math.max(L, this.alphas[j]));
                        if (Math.abs(this.alphas[j] - oldAj) < tol) continue;

                        this.alphas[i] += y[i] * y[j] * (oldAj - this.alphas[j]);

                        const b1 = this.b - Ei - y[i] * (this.alphas[i] - oldAi) * kernel(X[i], X[i]) - y[j] * (this.alphas[j] - oldAj) * kernel(X[i], X[j]);
                        const b2 = this.b - Ej - y[i] * (this.alphas[i] - oldAi) * kernel(X[i], X[j]) - y[j] * (this.alphas[j] - oldAj) * kernel(X[j], X[j]);

                        if (0 < this.alphas[i] && this.alphas[i] < C) {
                            this.b = b1;
                        } else if (0 < this.alphas[j] && this.alphas[j] < C) {
                            this.b = b2;
                        } else {
                            this.b = (b1 + b2) / 2;
                        }

                        numChangedAlphas++;
                    }
                }

                if (numChangedAlphas === 0) {
                    passes++;
                } else {
                    passes = 0;
                }
            }
        }

        predict(X) {
            return X.map(row => (this.decisionFunction(row) >= 0 ? 1 : -1));
        }

        decisionFunction(x) {
            return math.dot(this.alphas, y.map((yi, i) => yi * math.dot(X[i], x))) + this.b;
        }

        randomIndex(exclude, length) {
            let index;
            do {
                index = Math.floor(Math.random() * length);
            } while (index === exclude);
            return index;
        }
    }

    class NaiveBayesClassifier {
        fit(X, y) {
            const n = X[0].length;
            this.classes = [...new Set(y)];
            this.classCounts = this.classes.map(c => y.filter(yi => yi === c).length);
            this.classProbs = this.classCounts.map(count => count / y.length);

            this.featureProbs = this.classes.map(c => {
                const Xc = X.filter((_, i) => y[i] === c);
                const probs = Array(n).fill(0).map(() => ({}));
                Xc.forEach(row => {
                    row.forEach((value, i) => {
                        if (!probs[i][value]) probs[i][value] = 0;
                        probs[i][value]++;
                    });
                });
                probs.forEach((prob, i) => {
                    Object.keys(prob).forEach(key => {
                        prob[key] /= Xc.length;
                    });
                });
                return probs;
            });
        }

        predict(X) {
            return X.map(row => {
                const probs = this.classes.map((c, i) => {
                    return this.classProbs[i] * row.reduce((prob, value, j) => {
                        return prob * (this.featureProbs[i][j][value] || 1e-9);
                    }, 1);
                });
                return this.classes[probs.indexOf(Math.max(...probs))];
            });
        }
    }

    class KNNClassifier {
        fit(X, y) {
            this.X = X;
            this.y = y;
        }

        predict(X) {
            const k = 5;
            return X.map(row => {
                const distances = this.X.map((x, i) => ({
                    index: i,
                    distance: math.distance(row, x)
                }));
                distances.sort((a, b) => a.distance - b.distance);
                const neighbors = distances.slice(0, k);
                const classes = neighbors.map(neighbor => this.y[neighbor.index]);
                const counts = {};
                classes.forEach(c => counts[c] = (counts[c] || 0) + 1);
                return +Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
            });
        }
    }

    class KMeansCluster {
        fit(X, y) {
            const k = 3;
            const maxIterations = 100;
            this.centroids = X.slice(0, k);
            for (let iter = 0; iter < maxIterations; iter++) {
                const clusters = Array(k).fill(0).map(() => []);
                X.forEach(row => {
                    const distances = this.centroids.map(centroid => math.distance(row, centroid));
                    clusters[distances.indexOf(Math.min(...distances))].push(row);
                });
                this.centroids = clusters.map(cluster => math.mean(cluster, 0));
            }
        }

        predict(X) {
            return X.map(row => {
                const distances = this.centroids.map(centroid => math.distance(row, centroid));
                return distances.indexOf(Math.min(...distances));
            });
        }
    }

    class RandomForestClassifier {
        fit(X, y) {
            const nTrees = 10;
            const sampleSize = Math.floor(X.length / 2);
            this.trees = Array(nTrees).fill(0).map(() => {
                const sampleIndices = Array(sampleSize).fill(0).map(() => Math.floor(Math.random() * X.length));
                const sampleX = sampleIndices.map(i => X[i]);
                const sampleY = sampleIndices.map(i => y[i]);
                const tree = new DecisionTreeClassifier();
                tree.fit(sampleX, sampleY);
                return tree;
            });
        }

        predict(X) {
            const predictions = this.trees.map(tree => tree.predict(X));
            return X.map((_, i) => {
                const preds = predictions.map(pred => pred[i]);
                const counts = {};
                preds.forEach(p => counts[p] = (counts[p] || 0) + 1);
                return +Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
            });
        }
    }

    class PCA {
        fit(X, y) {
            const covarianceMatrix = math.cov(X);
            const { eigenvectors } = math.eigs(covarianceMatrix);
            this.components = eigenvectors;
        }

        predict(X) {
            return math.multiply(X, this.components);
        }
    }

    class GradientBoostingClassifier {
        fit(X, y) {
            const nEstimators = 100;
            const learningRate = 0.1;
            this.models = [];
            let residuals = y;

            for (let i = 0; i < nEstimators; i++) {
                const tree = new DecisionTreeClassifier();
                tree.fit(X, residuals);
                const preds = tree.predict(X);
                residuals = math.subtract(residuals, math.multiply(preds, learningRate));
                this.models.push(tree);
            }
        }

        predict(X) {
            return X.map(row => {
                const preds = this.models.map(tree => tree.predict([row])[0]);
                return math.sum(preds);
            });
        }
    }

    class AdaBoostClassifier {
        fit(X, y) {
            const nEstimators = 50;
            this.models = [];
            this.alphas = [];
            let weights = Array(y.length).fill(1 / y.length);

            for (let i = 0; i < nEstimators; i++) {
                const tree = new DecisionTreeClassifier();
                tree.fit(X, y, weights);
                const preds = tree.predict(X);
                const error = weights.reduce((sum, w, j) => sum + w * (preds[j] !== y[j]), 0);
                const alpha = 0.5 * Math.log((1 - error) / (error + 1e-10));
                weights = weights.map((w, j) => w * Math.exp(-alpha * y[j] * preds[j]));
                const sumWeights = math.sum(weights);
                weights = weights.map(w => w / sumWeights);
                this.models.push(tree);
                this.alphas.push(alpha);
            }
        }

        predict(X) {
            return X.map(row => {
                const weightedSum = this.models.reduce((sum, tree, i) => sum + this.alphas[i] * tree.predict([row])[0], 0);
                return weightedSum >= 0 ? 1 : -1;
            });
        }
    }

    function calculateMetrics(yTrue, yPred, problemType) {
        const tp = yTrue.filter((y, i) => y === 1 && yPred[i] === 1).length;
        const tn = yTrue.filter((y, i) => y === 0 && yPred[i] === 0).length;
        const fp = yTrue.filter((y, i) => y === 0 && yPred[i] === 1).length;
        const fn = yTrue.filter((y, i) => y === 1 && yPred[i] === 0).length;

        const accuracy = (tp + tn) / yTrue.length;
        const precision = tp / (tp + fp);
        const recall = tp / (tp + fn);
        const f1_score = 2 * (precision * recall) / (precision + recall);
        const specificity = tn / (tn + fp);
        const lr_plus = recall / (1 - specificity);
        const odds_ratio = (tp * tn) / (fp * fn);
        const prevalence_threshold = (Math.sqrt(tp + fn) - Math.sqrt(fp + tn)) / (tp + tn + fp + fn);

        const roc_auc = calculateAUC(yTrue, yPred);
        const roc_curve = rocCurve(yTrue, yPred);

        return {
            confusion_matrix: [[tn, fp], [fn, tp]],
            accuracy,
            precision,
            recall,
            f1_score,
            specificity,
            lr_plus,
            odds_ratio,
            prevalence_threshold,
            roc_auc,
            roc_curve
        };
    }

    function calculateAUC(yTrue, yPred) {
        const sorted = yPred.map((pred, i) => ({ pred, actual: yTrue[i] })).sort((a, b) => b.pred - a.pred);
        let tp = 0, fp = 0;
        let prev_tp = 0, prev_fp = 0;
        let auc = 0;

        sorted.forEach(({ pred, actual }) => {
            if (actual === 1) tp++;
            else fp++;

            if (prev_fp !== fp) {
                auc += (tp + prev_tp) * (fp - prev_fp) / 2;
                prev_tp = tp;
                prev_fp = fp;
            }
        });

        return auc / (tp * fp);
    }

    function rocCurve(yTrue, yPred) {
        const thresholds = [...new Set(yPred)].sort((a, b) => a - b);
        const rocPoints = thresholds.map(threshold => {
            const tp = yTrue.filter((y, i) => y === 1 && yPred[i] >= threshold).length;
            const fp = yTrue.filter((y, i) => y === 0 && yPred[i] >= threshold).length;
            const fn = yTrue.filter((y, i) => y === 1 && yPred[i] < threshold).length;
            const tn = yTrue.filter((y, i) => y === 0 && yPred[i] < threshold).length;

            const tpr = tp / (tp + fn);
            const fpr = fp / (fp + tn);

            return { tpr, fpr };
        });

        return rocPoints;
    }
</script>

</body>
</html>
