<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Run Your ML Model</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: auto; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; }
        .form-group textarea, .form-group select, .form-group input { width: 100%; padding: 8px; }
        .form-group button { padding: 10px 20px; }
        .result, .status, .preview, .progress, .console { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
        .progress progress { width: 100%; }
        #chart { width: 100%; height: 400px; }
        .console { background-color: #000; color: #0f0; font-family: monospace; height: 200px; overflow-y: scroll; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@9.4.4/lib/browser/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<div class="container">
    <h1>Run Your ML Model</h1>

    <div class="form-group">
        <label for="dataInput">Enter Data (CSV format: first row containing variable names, then variable values)</label>
        <textarea id="dataInput" rows="10" placeholder="Enter data in CSV format"></textarea>
    </div>

    <div class="form-group">
        <button onclick="previewData()">Preview Data</button>
    </div>

    <div class="form-group">
        <label for="dependentVar">Select Dependent Variable</label>
        <select id="dependentVar"></select>
    </div>

    <div class="form-group">
        <label for="independentVars">Select Independent Variables</label>
        <select id="independentVars" multiple></select>
    </div>

    <div class="form-group">
        <label for="problemType">Select Problem Type</label>
        <select id="problemType">
            <option value="classification">Classification</option>
            <option value="regression">Regression</option>
        </select>
    </div>

    <div class="form-group">
        <button onclick="runModel()">Run Model</button>
    </div>

    <div class="progress">
        <progress id="progressBar" value="0" max="100"></progress>
        <span id="progressText">0%</span>
    </div>

    <div class="status" id="status"></div>
    <div class="console" id="console"></div>
    <div class="preview" id="preview"></div>
    <div class="result" id="result"></div>
    <canvas id="chart"></canvas>
</div>

<script>
    let X, y;
    const models = {
        regression: [
            new LinearRegression(),
            new DecisionTreeRegressor(),
            new RandomForestRegressor(),
            new GradientBoostingRegressor(),
            new AdaBoostRegressor(),
        ],
        classification: [
            new LogisticRegression(),
            new DecisionTreeClassifier(),
            new SVMClassifier(),
            new NaiveBayesClassifier(),
            new KNNClassifier(),
            new RandomForestClassifier(),
            new GradientBoostingClassifier(),
            new AdaBoostClassifier()
        ]
    };

    function previewData() {
        const dataInput = document.getElementById('dataInput').value;
        displayPreview(dataInput);
    }

    function displayPreview(content) {
        const rows = content.split('\n');
        const previewDiv = document.getElementById('preview');
        previewDiv.innerHTML = `<h2>Preview of Data (First 5 Rows)</h2>`;
        rows.slice(0, 5).forEach(row => {
            previewDiv.innerHTML += `<pre>${row}</pre>`;
        });

        const columns = rows[0].split(',');
        populateDropdowns(columns);
    }

    function populateDropdowns(columns) {
        const dependentVar = document.getElementById('dependentVar');
        const independentVars = document.getElementById('independentVars');
        dependentVar.innerHTML = '';
        independentVars.innerHTML = '';

        columns.forEach(col => {
            const option = document.createElement('option');
            option.value = col;
            option.textContent = col;
            dependentVar.appendChild(option);

            const multiOption = option.cloneNode(true);
            independentVars.appendChild(multiOption);
        });
    }

    function updateProgress(progress) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        progressBar.value = progress;
        progressText.textContent = `${progress}%`;
    }

    function logToConsole(message) {
        const consoleDiv = document.getElementById('console');
        consoleDiv.innerHTML += `<div>${message}</div>`;
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    function runModel() {
        const statusDiv = document.getElementById('status');
        const dependentVar = document.getElementById('dependentVar').value;
        const independentVars = Array.from(document.getElementById('independentVars').selectedOptions).map(opt => opt.value);
        const problemType = document.getElementById('problemType').value;

        statusDiv.textContent = `Running model...`;
        logToConsole(`Starting model run...`);
        updateProgress(0);

        const dataInput = document.getElementById('dataInput').value;
        const rows = dataInput.split('\n').map(row => row.split(','));
        const headers = rows[0];
        const data = rows.slice(1).map(row => row.map(cell => parseFloat(cell)));

        const depIndex = headers.indexOf(dependentVar);
        const indIndexes = independentVars.map(v => headers.indexOf(v));

        X = data.map(row => indIndexes.map(i => row[i]));
        y = data.map(row => row[depIndex]);

        if (problemType === 'regression') {
            if (applicabilityCheck('regression', X, y)) {
                runRegressionModels();
            } else {
                logToConsole('Regression model applicability check failed.');
                statusDiv.textContent = 'Regression model applicability check failed.';
            }
        } else {
            if (applicabilityCheck('classification', X, y)) {
                runClassificationModels();
            } else {
                logToConsole('Classification model applicability check failed.');
                statusDiv.textContent = 'Classification model applicability check failed.';
            }
        }
    }

    function applicabilityCheck(type, X, y) {
        if (type === 'regression') {
            if (X.length <= X[0].length) {
                logToConsole('Applicability Check Failed: More observations are needed than the number of features.');
                return false;
            }
            const corrMatrix = math.transpose(X).map((col, idx) => {
                return math.corr(col, y);
            });
            if (corrMatrix.some(corr => Math.abs(corr) < 0.3)) {
                logToConsole('Applicability Check Failed: Low correlation between independent and dependent variables.');
                return false;
            }
        } else if (type === 'classification') {
            const classCounts = y.reduce((acc, val) => {
                acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});
            if (Object.values(classCounts).some(count => count < 10 * X[0].length)) {
                logToConsole('Applicability Check Failed: Not enough occurrences per feature for each class.');
                return false;
            }
        }
        return true;
    }

    function runRegressionModels() {
        let progress = 30;
        const progressIncrement = 70 / models.regression.length;

        models.regression.forEach((model, index) => {
            setTimeout(() => {
                try {
                    logToConsole(`Fitting model: ${model.constructor.name}`);
                    model.fit(X, y);
                    logToConsole(`Model ${model.constructor.name} fitted successfully`);
                    const yPred = model.predict(X);
                    logToConsole(`Model ${model.constructor.name} prediction done`);
                    const result = calculateMetrics(y, yPred, 'regression');
                    displayResult(result, model.constructor.name);

                    progress += progressIncrement;
                    updateProgress(progress);

                    if (index === models.regression.length - 1) {
                        setTimeout(() => {
                            updateProgress(100);
                            document.getElementById('status').textContent = 'Model run successfully';
                            logToConsole(`Model run completed successfully`);
                        }, 500);
                    }
                } catch (error) {
                    logToConsole(`Error in model ${model.constructor.name}: ${error.message}`);
                }
            }, index * 500);
        });
    }

    function runClassificationModels() {
        let progress = 30;
        const progressIncrement = 70 / models.classification.length;

        models.classification.forEach((model, index) => {
            setTimeout(() => {
                try {
                    logToConsole(`Fitting model: ${model.constructor.name}`);
                    model.fit(X, y);
                    logToConsole(`Model ${model.constructor.name} fitted successfully`);
                    const yPred = model.predict(X);
                    logToConsole(`Model ${model.constructor.name} prediction done`);
                    const result = calculateMetrics(y, yPred, 'classification');
                    displayResult(result, model.constructor.name);

                    progress += progressIncrement;
                    updateProgress(progress);

                    if (index === models.classification.length - 1) {
                        setTimeout(() => {
                            updateProgress(100);
                            document.getElementById('status').textContent = 'Model run successfully';
                            logToConsole(`Model run completed successfully`);
                        }, 500);
                    }
                } catch (error) {
                    logToConsole(`Error in model ${model.constructor.name}: ${error.message}`);
                }
            }, index * 500);
        });
    }

    function calculateMetrics(y, yPred, problemType) {
        if (problemType === 'regression') {
            const mse = math.mean(y.map((val, i) => Math.pow(val - yPred[i], 2)));
            const rmse = Math.sqrt(mse);
            const mae = math.mean(y.map((val, i) => Math.abs(val - yPred[i])));
            return {
                mse,
                rmse,
                mae
            };
        } else {
            let tp = 0, tn = 0, fp = 0, fn = 0;
            for (let i = 0; i < y.length; i++) {
                if (y[i] === 1 && yPred[i] == 1) tp++;
                if (y[i] === 0 && yPred[i] == 0) tn++;
                if (y[i] === 0 && yPred[i] == 1) fp++;
                if (y[i] === 1 && yPred[i] == 0) fn++;
            }

            const accuracy = (tp + tn) / (tp + tn + fp + fn);
            const precision = tp / (tp + fp);
            const recall = tp / (tp + fn);
            const f1_score = 2 * (precision * recall) / (precision + recall);
            const specificity = tn / (tn + fp);
            const lr_plus = recall / (1 - specificity);
            const odds_ratio = (tp * tn) / (fp * fn);
            const prevalence_threshold = (Math.sqrt(tp + fn) - Math.sqrt(fp + tn)) / (tp + tn + fp + fn);

            return {
                confusion_matrix: [[tp, fp], [fn, tn]],
                accuracy,
                precision,
                recall,
                f1_score,
                specificity,
                lr_plus,
                odds_ratio,
                prevalence_threshold,
                roc_curve: calculateROCCurve(y, yPred)
            };
        }
    }

    function calculateROCCurve(y, yPred) {
        const thresholds = [...new Set(yPred)].sort((a, b) => a - b);
        const rocCurve = thresholds.map(threshold => {
            let tp = 0, tn = 0, fp = 0, fn = 0;
            y.forEach((actual, index) => {
                const predicted = yPred[index] >= threshold ? 1 : 0;
                if (actual === 1 && predicted === 1) tp++;
                if (actual === 0 && predicted === 0) tn++;
                if (actual === 0 && predicted === 1) fp++;
                if (actual === 1 && predicted === 0) fn++;
            });
            const tpr = tp / (tp + fn);
            const fpr = fp / (fp + tn);
            return { tpr, fpr };
        });
        return rocCurve;
    }

    function displayResult(result, modelName) {
        const resultDiv = document.getElementById('result');
        resultDiv.innerHTML += `
            <h2>${modelName} Results</h2>
            <pre>${JSON.stringify(result, null, 2)}</pre>
            <h3>Evaluation Metrics</h3>
        `;
        if (result.confusion_matrix) {
            resultDiv.innerHTML += `
                <p><b>Confusion Matrix:</b> [[${result.confusion_matrix[0][0]}, ${result.confusion_matrix[0][1]}], [${result.confusion_matrix[1][0]}, ${result.confusion_matrix[1][1]}]]</p>
                <p><b>Accuracy:</b> ${result.accuracy}</p>
                <p><b>Precision:</b> ${result.precision}</p>
                <p><b>Recall:</b> ${result.recall}</p>
                <p><b>F1 Score:</b> ${result.f1_score}</p>
                <p><b>Specificity:</b> ${result.specificity}</p>
                <p><b>LR+:</b> ${result.lr_plus}</p>
                <p><b>Odds Ratio:</b> ${result.odds_ratio}</p>
                <p><b>Prevalence Threshold:</b> ${result.prevalence_threshold}</p>
            `;
            displayGraph(result.roc_curve, modelName);
        } else {
            resultDiv.innerHTML += `
                <p><b>MSE:</b> ${result.mse}</p>
                <p><b>RMSE:</b> ${result.rmse}</p>
                <p><b>MAE:</b> ${result.mae}</p>
            `;
        }
    }

    function displayGraph(rocCurve, modelName) {
        const ctx = document.getElementById('chart').getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: rocCurve.map(point => point.fpr),
                datasets: [{
                    label: `${modelName} ROC Curve`,
                    data: rocCurve.map(point => ({ x: point.fpr, y: point.tpr })),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom'
                    }
                }
            }
        });
    }

    class LinearRegression {
        fit(X, y) {
            X = X.map(row => [1, ...row]);
            const Xt = math.transpose(X);
            const XtX = math.multiply(Xt, X);
            const XtX_inv = math.inv(XtX);
            const XtX_inv_Xt = math.multiply(XtX_inv, Xt);
            this.coef_ = math.multiply(XtX_inv_Xt, y);
        }

        predict(X) {
            X = X.map(row => [1, ...row]);
            return math.multiply(X, this.coef_);
        }
    }

    class LogisticRegression {
        fit(X, y) {
            X = X.map(row => [1, ...row]);
            const sigmoid = z => 1 / (1 + Math.exp(-z));
            this.coef_ = Array(X[0].length).fill(0);
            const learningRate = 0.01;
            const iterations = 1000;

            for (let i = 0; i < iterations; i++) {
                const z = math.multiply(X, this.coef_);
                const h = z.map(sigmoid);
                const gradient = math.multiply(math.transpose(X), math.subtract(h, y));
                this.coef_ = math.subtract(this.coef_, math.multiply(learningRate, gradient));
            }
        }

        predict(X) {
            X = X.map(row => [1, ...row]);
            const z = math.multiply(X, this.coef_);
            const sigmoid = z => 1 / (1 + Math.exp(-z));
            const probs = z.map(sigmoid);
            return probs.map(p => (p >= 0.5 ? 1 : 0));
        }
    }

    class DecisionTreeClassifier {
        fit(X, y) {
            const buildTree = (X, y, depth = 0) => {
                if (depth === 5 || y.every(val => val === y[0])) {
                    return { value: y[0] };
                }

                let bestFeature, bestThreshold, bestGini = Infinity;
                for (let feature = 0; feature < X[0].length; feature++) {
                    const thresholds = [...new Set(X.map(row => row[feature]))];
                    for (const threshold of thresholds) {
                        const [leftX, leftY, rightX, rightY] = this.split(X, y, feature, threshold);
                        const gini = this.giniImpurity(leftY, rightY);
                        if (gini < bestGini) {
                            bestGini = gini;
                            bestFeature = feature;
                            bestThreshold = threshold;
                        }
                    }
                }

                const [leftX, leftY, rightX, rightY] = this.split(X, y, bestFeature, bestThreshold);
                return {
                    feature: bestFeature,
                    threshold: bestThreshold,
                    left: buildTree(leftX, leftY, depth + 1),
                    right: buildTree(rightX, rightY, depth + 1)
                };
            };

            this.tree = buildTree(X, y);
        }

        predict(X) {
            const traverse = (node, row) => {
                if (node.value !== undefined) {
                    return node.value;
                }
                if (row[node.feature] < node.threshold) {
                    return traverse(node.left, row);
                } else {
                    return traverse(node.right, row);
                }
            };

            return X.map(row => traverse(this.tree, row));
        }

        split(X, y, feature, threshold) {
            const leftX = [], leftY = [], rightX = [], rightY = [];
            for (let i = 0; i < X.length; i++) {
                if (X[i][feature] < threshold) {
                    leftX.push(X[i]);
                    leftY.push(y[i]);
                } else {
                    rightX.push(X[i]);
                    rightY.push(y[i]);
                }
            }
            return [leftX, leftY, rightX, rightY];
        }

        giniImpurity(leftY, rightY) {
            const leftSize = leftY.length;
            const rightSize = rightY.length;
            const totalSize = leftSize + rightSize;
            const gini = side => 1 - side.reduce((acc, val) => {
                const p = side.filter(v => v === val).length / side.length;
                return acc + p * p;
            }, 0);
            return (leftSize / totalSize) * gini(leftY) + (rightSize / totalSize) * gini(rightY);
        }
    }

    class SVMClassifier {
        fit(X, y) {
            const C = 1.0;
            const tol = 1e-3;
            const maxPasses = 5;
            const kernel = (x1, x2) => math.dot(x1, x2);

            this.alphas = Array(y.length).fill(0);
            this.b = 0;

            let passes = 0;
            while (passes < maxPasses) {
                let numChangedAlphas = 0;
                for (let i = 0; i < y.length; i++) {
                    const Ei = this.decisionFunction(X[i]) - y[i];
                    if ((y[i] * Ei < -tol && this.alphas[i] < C) || (y[i] * Ei > tol && this.alphas[i] > 0)) {
                        const j = this.randomIndex(i, y.length);
                        const Ej = this.decisionFunction(X[j]) - y[j];
                        const oldAi = this.alphas[i];
                        const oldAj = this.alphas[j];
                        const L = Math.max(0, oldAj - oldAi);
                        const H = Math.min(C, C + oldAj - oldAi);
                        if (L === H) continue;

                        const eta = 2 * kernel(X[i], X[j]) - kernel(X[i], X[i]) - kernel(X[j], X[j]);
                        if (eta >= 0) continue;

                        this.alphas[j] -= y[j] * (Ei - Ej) / eta;
                        this.alphas[j] = Math.min(H, Math.max(L, this.alphas[j]));
                        if (Math.abs(this.alphas[j] - oldAj) < tol) continue;

                        this.alphas[i] += y[i] * y[j] * (oldAj - this.alphas[j]);

                        const b1 = this.b - Ei - y[i] * (this.alphas[i] - oldAi) * kernel(X[i], X[i]) - y[j] * (this.alphas[j] - oldAj) * kernel(X[i], X[j]);
                        const b2 = this.b - Ej - y[i] * (this.alphas[i] - oldAi) * kernel(X[i], X[j]) - y[j] * (this.alphas[j] - oldAj) * kernel(X[j], X[j]);

                        if (0 < this.alphas[i] && this.alphas[i] < C) {
                            this.b = b1;
                        } else if (0 < this.alphas[j] && this.alphas[j] < C) {
                            this.b = b2;
                        } else {
                            this.b = (b1 + b2) / 2;
                        }

                        numChangedAlphas++;
                    }
                }

                if (numChangedAlphas === 0) {
                    passes++;
                } else {
                    passes = 0;
                }
            }
        }

        predict(X) {
            return X.map(row => (this.decisionFunction(row) >= 0 ? 1 : -1));
        }

        decisionFunction(x) {
            return math.dot(this.alphas, y.map((yi, i) => yi * math.dot(X[i], x))) + this.b;
        }

        randomIndex(exclude, length) {
            let index;
            do {
                index = Math.floor(Math.random() * length);
            } while (index === exclude);
            return index;
        }
    }

    class NaiveBayesClassifier {
        fit(X, y) {
            const n = X[0].length;
            this.classes = [...new Set(y)];
            this.classCounts = this.classes.map(c => y.filter(yi => yi === c).length);
            this.classProbs = this.classCounts.map(count => count / y.length);

            this.featureProbs = this.classes.map(c => {
                const Xc = X.filter((_, i) => y[i] === c);
                const probs = Array(n).fill(0).map(() => ({}));
                Xc.forEach(row => {
                    row.forEach((value, i) => {
                        if (!probs[i][value]) probs[i][value] = 0;
                        probs[i][value]++;
                    });
                });
                probs.forEach((prob, i) => {
                    Object.keys(prob).forEach(key => {
                        prob[key] /= Xc.length;
                    });
                });
                return probs;
            });
        }

        predict(X) {
            return X.map(row => {
                const probs = this.classes.map((c, i) => {
                    return this.classProbs[i] * row.reduce((prob, value, j) => {
                        return prob * (this.featureProbs[i][j][value] || 1e-9);
                    }, 1);
                });
                return this.classes[probs.indexOf(Math.max(...probs))];
            });
        }
    }

    class KNNClassifier {
        fit(X, y) {
            this.X = X;
            this.y = y;
        }

        predict(X) {
            const k = 5;
            return X.map(row => {
                const distances = this.X.map((x, i) => ({
                    index: i,
                    distance: math.distance(row, x)
                }));
                distances.sort((a, b) => a.distance - b.distance);
                const neighbors = distances.slice(0, k);
                const classes = neighbors.map(neighbor => this.y[neighbor.index]);
                const counts = {};
                classes.forEach(c => counts[c] = (counts[c] || 0) + 1);
                return +Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
            });
        }
    }

    class DecisionTreeRegressor extends DecisionTreeClassifier {}
    class RandomForestRegressor extends RandomForestClassifier {}
    class GradientBoostingRegressor extends GradientBoostingClassifier {}
    class AdaBoostRegressor extends AdaBoostClassifier {}

</script>
</body>
</html>
