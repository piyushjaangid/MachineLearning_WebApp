<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Run Your ML Model</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: auto; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; }
        .form-group textarea, .form-group select, .form-group input { width: 100%; padding: 8px; }
        .form-group button { padding: 10px 20px; }
        .result, .status, .preview, .progress, .console { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
        .progress progress { width: 100%; }
        #chart { width: 100%; height: 400px; }
        .console { background-color: #000; color: #0f0; font-family: monospace; height: 200px; overflow-y: scroll; }
        .control { margin-bottom: 15px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@9.4.4/lib/browser/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tfjs@1.2.9/dist/tf.min.js"></script>
</head>
<body>

<div class="container">
    <h1>Run Your ML Model</h1>

    <div class="form-group">
        <label for="dataInput">Enter Data (CSV format: first row containing variable names, then variable values)</label>
        <textarea id="dataInput" rows="10" placeholder="Enter data in CSV format"></textarea>
    </div>

    <div class="form-group">
        <button onclick="previewData()">Preview Data</button>
        <input type="file" id="fileInput" accept=".csv,.xlsx" />
        <button onclick="loadFile()">Load File</button>
    </div>

    <div class="form-group">
        <label for="dependentVar">Select Dependent Variable</label>
        <select id="dependentVar"></select>
    </div>

    <div class="form-group">
        <label for="independentVars">Select Independent Variables</label>
        <select id="independentVars" multiple></select>
    </div>

    <div class="form-group">
        <label for="problemType">Select Problem Type</label>
        <select id="problemType">
            <option value="classification">Classification</option>
            <option value="regression">Regression</option>
        </select>
    </div>

    <div class="progress">
        <progress id="progressBar" value="0" max="100"></progress>
        <span id="progressText">0%</span>
    </div>

    <div class="status" id="status"></div>
    <div class="console" id="console"></div>
    <div class="preview" id="preview"></div>
    <div class="result" id="result"></div>
    <canvas id="chart"></canvas>

    <!-- Visual Controls -->
    <div id="top-controls" class="control">
        <div class="timeline-controls">
            <button id="reset-button" title="Reset the network">Reset</button>
            <button id="play-pause-button" title="Run/Pause">Run</button>
            <button id="next-step-button" title="Step">Step</button>
        </div>
        <div class="control">
            <span class="label">Epoch</span>
            <span class="value" id="iter-number"></span>
        </div>
        <div class="control">
            <label for="learningRate">Learning rate</label>
            <select id="learningRate">
                <option value="0.00001">0.00001</option>
                <option value="0.0001">0.0001</option>
                <option value="0.001">0.001</option>
                <option value="0.003">0.003</option>
                <option value="0.01">0.01</option>
                <option value="0.03">0.03</option>
                <option value="0.1">0.1</option>
                <option value="0.3">0.3</option>
                <option value="1">1</option>
                <option value="3">3</option>
                <option value="10">10</option>
            </select>
        </div>
        <div class="control">
            <label for="activations">Activation</label>
            <select id="activations">
                <option value="relu">ReLU</option>
                <option value="tanh">Tanh</option>
                <option value="sigmoid">Sigmoid</option>
                <option value="linear">Linear</option>
            </select>
        </div>
        <div class="control">
            <label for="regularizations">Regularization</label>
            <select id="regularizations">
                <option value="none">None</option>
                <option value="L1">L1</option>
                <option value="L2">L2</option>
            </select>
        </div>
        <div class="control">
            <label for="regularRate">Regularization rate</label>
            <select id="regularRate">
                <option value="0">0</option>
                <option value="0.001">0.001</option>
                <option value="0.003">0.003</option>
                <option value="0.01">0.01</option>
                <option value="0.03">0.03</option>
                <option value="0.1">0.1</option>
                <option value="0.3">0.3</option>
                <option value="1">1</option>
                <option value="3">3</option>
                <option value="10">10</option>
            </select>
        </div>
    </div>

    <div id="main-part" class="control">
        <div class="column data">
            <h4>Data</h4>
            <div class="ui-dataset">
                <p>Which dataset do you want to use?</p>
                <div class="dataset-list">
                    <div class="dataset" title="Circle">
                        <canvas class="data-thumbnail" data-dataset="circle"></canvas>
                    </div>
                    <div class="dataset" title="Exclusive or">
                        <canvas class="data-thumbnail" data-dataset="xor"></canvas>
                    </div>
                    <div class="dataset" title="Gaussian">
                        <canvas class="data-thumbnail" data-dataset="gauss"></canvas>
                    </div>
                    <div class="dataset" title="Spiral">
                        <canvas class="data-thumbnail" data-dataset="spiral"></canvas>
                    </div>
                    <div class="dataset" title="Plane">
                        <canvas class="data-thumbnail" data-regDataset="reg-plane"></canvas>
                    </div>
                    <div class="dataset" title="Multi gaussian">
                        <canvas class="data-thumbnail" data-regDataset="reg-gauss"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="column features">
            <h4>Features</h4>
            <p>Which properties do you want to feed in?</p>
            <div id="network">
                <svg id="svg" width="510" height="450">
                    <defs>
                        <marker id="markerArrow" markerWidth="7" markerHeight="13" refX="1" refY="6" orient="auto" markerUnits="userSpaceOnUse">
                            <path d="M2,11 L7,6 L2,2" />
                        </marker>
                    </defs>
                </svg>
                <div id="hovercard">
                    <div style="font-size:10px">Click anywhere to edit.</div>
                    <div><span class="type">Weight/Bias</span> is <span class="value">0.2</span><span><input type="number"/></span>.</div>
                </div>
                <div class="callout thumbnail">
                    <svg viewBox="0 0 30 30">
                        <defs>
                            <marker id="arrow" markerWidth="5" markerHeight="5" refx="5" refy="2.5" orient="auto" markerUnits="userSpaceOnUse">
                                <path d="M0,0 L5,2.5 L0,5 z"/>
                            </marker>
                        </defs>
                        <path d="M12,30C5,20 2,15 12,0" marker-end="url(#arrow)">
                    </svg>
                    <div class="label">
                        This is the output from one <b>neuron</b>. Hover to see it larger.
                    </div>
                </div>
                <div class="callout weights">
                    <svg viewBox="0 0 30 30">
                        <defs>
                            <marker id="arrow" markerWidth="5" markerHeight="5" refx="5" refy="2.5" orient="auto" markerUnits="userSpaceOnUse">
                                <path d="M0,0 L5,2.5 L0,5 z"/>
                            </marker>
                        </defs>
                        <path d="M12,30C5,20 2,15 12,0" marker-end="url(#arrow)">
                    </svg>
                    <div class="label">
                        The outputs are mixed with varying <b>weights</b>, shown by the thickness of the lines.
                    </div>
                </div>
            </div>
        </div>
        <div class="column hidden-layers">
            <h4>
                <div class="ui-numHiddenLayers">
                    <button id="add-layers" class="mdl-button mdl-js-button mdl-button--icon">
                        <i class="material-icons">add</i>
                    </button>
                    <button id="remove-layers" class="mdl-button mdl-js-button mdl-button--icon">
                        <i class="material-icons">remove</i>
                    </button>
                </div>
                <span id="num-layers"></span>
                <span id="layers-label"></span>
            </h4>
            <div class="bracket"></div>
        </div>
        <div class="column output">
            <h4>Output</h4>
            <div class="metrics">
                <div class="output-stats ui-percTrainData">
                    <span>Test loss</span>
                    <div class="value" id="loss-test"></div>
                </div>
                <div class="output-stats train">
                    <span>Training loss</span>
                    <div class="value" id="loss-train"></div>
                </div>
                <div id="linechart"></div>
            </div>
            <div id="heatmap"></div>
            <div style="float:left;margin-top:20px">
                <div style="display:flex; align-items:center;">
                    <div class="label" style="width:105px; margin-right: 10px">
                        Colors shows data, neuron and weight values.
                    </div>
                    <svg width="150" height="30" id="colormap">
                        <defs>
                            <linearGradient id="gradient" x1="0%" y1="100%" x2="100%" y2="100%">
                                <stop offset="0%" stop-color="#f59322" stop-opacity="1"></stop>
                                <stop offset="50%" stop-color="#e8eaeb" stop-opacity="1"></stop>
                                <stop offset="100%" stop-color="#0877bd" stop-opacity="1"></stop>
                            </linearGradient>
                        </defs>
                        <g class="core" transform="translate(3, 0)">
                            <rect width="144" height="10" style="fill: url('#gradient');"></rect>
                        </g>
                    </svg>
                </div>
                <br/>
                <div style="display:flex;">
                    <label class="ui-showTestData mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect" for="show-test-data">
                        <input type="checkbox" id="show-test-data" class="mdl-checkbox__input" checked>
                        <span class="mdl-checkbox__label label">Show test data</span>
                    </label>
                    <label class="ui-discretize mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect" for="discretize">
                        <input type="checkbox" id="discretize" class="mdl-checkbox__input" checked>
                        <span class="mdl-checkbox__label label">Discretize output</span>
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    function previewData() {
        const dataInput = document.getElementById('dataInput').value;
        displayPreview(dataInput);
    }

    function displayPreview(content) {
        const rows = content.split('\n');
        const previewDiv = document.getElementById('preview');
        previewDiv.innerHTML = `<h2>Preview of Data (First 5 Rows)</h2>`;
        rows.slice(0, 5).forEach(row => {
            previewDiv.innerHTML += `<pre>${row}</pre>`;
        });

        const columns = rows[0].split(',');
        populateDropdowns(columns);
    }

    function populateDropdowns(columns) {
        const dependentVar = document.getElementById('dependentVar');
        const independentVars = document.getElementById('independentVars');
        dependentVar.innerHTML = '';
        independentVars.innerHTML = '';

        columns.forEach(col => {
            const option = document.createElement('option');
            option.value = col;
            option.textContent = col;
            dependentVar.appendChild(option);

            const multiOption = option.cloneNode(true);
            independentVars.appendChild(multiOption);
        });
    }

    function loadFile() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];
        const reader = new FileReader();

        reader.onload = function(e) {
            const content = e.target.result;
            document.getElementById('dataInput').value = content;
            previewData();
        };

        reader.readAsText(file);
    }

    function updateProgress(progress) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        progressBar.value = progress;
        progressText.textContent = `${progress}%`;
    }

    function logToConsole(message) {
        const consoleDiv = document.getElementById('console');
        consoleDiv.innerHTML += `<div>${message}</div>`;
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    function runModel() {
        const statusDiv = document.getElementById('status');
        const dependentVar = document.getElementById('dependentVar').value;
        const independentVars = Array.from(document.getElementById('independentVars').selectedOptions).map(opt => opt.value);
        const problemType = document.getElementById('problemType').value;

        statusDiv.textContent = `Running model...`;
        logToConsole(`Starting model run...`);
        updateProgress(0);

        const dataInput = document.getElementById('dataInput').value;
        const rows = dataInput.split('\n').map(row => row.split(','));
        const headers = rows[0];
        const data = rows.slice(1).map(row => row.map(cell => parseFloat(cell)));

        const depIndex = headers.indexOf(dependentVar);
        const indIndexes = independentVars.map(v => headers.indexOf(v));

        const X = data.map(row => indIndexes.map(i => row[i]));
        const y = data.map(row => row[depIndex]);

        const algorithms = problemType === 'regression' ? [
            new LinearRegression(),
            new DecisionTreeRegressor(),
            new RandomForestRegressor(),
            new GradientBoostingRegressor(),
            new AdaBoostRegressor()
        ] : [
            new LogisticRegression(),
            new DecisionTreeClassifier(),
            new SVMClassifier(),
            new NaiveBayesClassifier(),
            new KNNClassifier(),
            new RandomForestClassifier(),
            new GradientBoostingClassifier(),
            new AdaBoostClassifier()
        ];

        let progressIncrement = 70 / algorithms.length;
        let progress = 30;

        algorithms.forEach((model, index) => {
            setTimeout(() => {
                try {
                    logToConsole(`Fitting model: ${model.constructor.name}`);
                    model.fit(X, y);
                    logToConsole(`Model ${model.constructor.name} fitted successfully`);
                    const yPred = model.predict(X);
                    logToConsole(`Model ${model.constructor.name} prediction done`);
                    const result = calculateMetrics(y, yPred, problemType);
                    displayResult(result, model.constructor.name);

                    progress += progressIncrement;
                    updateProgress(progress);

                    if (index === algorithms.length - 1) {
                        setTimeout(() => {
                            updateProgress(100);
                            statusDiv.textContent = 'Model run successfully';
                            logToConsole(`Model run completed successfully`);
                        }, 500);
                    }
                } catch (error) {
                    logToConsole(`Error in model ${model.constructor.name}: ${error.message}`);
                }
            }, index * 500);
        });
    }

    function displayResult(result, modelName) {
        const resultDiv = document.getElementById('result');
        resultDiv.innerHTML += `
            <h2>${modelName} Results</h2>
            <pre>${JSON.stringify(result, null, 2)}</pre>
            <h3>Evaluation Metrics</h3>
            <p><b>Confusion Matrix:</b> [[${result.confusion_matrix[0][0]}, ${result.confusion_matrix[0][1]}], [${result.confusion_matrix[1][0]}, ${result.confusion_matrix[1][1]}]]</p>
            <p><b>Accuracy:</b> ${result.accuracy} = (TP + TN) / (TP + TN + FP + FN)</p>
            <p><b>Precision:</b> ${result.precision} = TP / (TP + FP)</p>
            <p><b>Recall:</b> ${result.recall} = TP / (TP + FN)</p>
            <p><b>F1 Score:</b> ${result.f1_score} = 2 * (Precision * Recall) / (Precision + Recall)</p>
            <p><b>Specificity:</b> ${result.specificity} = TN / (TN + FP)</p>
            <p><b>LR+:</b> ${result.lr_plus} = Recall / (1 - Specificity)</p>
            <p><b>Odds Ratio:</b> ${result.odds_ratio} = (TP * TN) / (FP * FN)</p>
            <p><b>Prevalence Threshold:</b> ${result.prevalence_threshold} = (sqrt(TP + FN) - sqrt(FP + TN)) / (TP + TN + FP + FN)</p>
        `;

        displayGraph(result.roc_curve, modelName);
    }

    function displayGraph(rocCurve, modelName) {
        const ctx = document.getElementById('chart').getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: rocCurve.map(point => point.fpr),
                datasets: [{
                    label: `${modelName} ROC Curve`,
                    data: rocCurve.map(point => point.tpr),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 2,
                    fill: false
                }]
            },
            options: {
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'False Positive Rate'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'True Positive Rate'
                        }
                    }
                }
            }
        });
    }

    // Model Classes

    class LinearRegression {
        fit(X, y) {
            X = X.map(row => [1, ...row]);
            const Xt = math.transpose(X);
            const XtX = math.multiply(Xt, X);
            const XtX_inv = math.inv(XtX);
            const XtX_inv_Xt = math.multiply(XtX_inv, Xt);
            this.coef_ = math.multiply(XtX_inv_Xt, y);
        }

        predict(X) {
            X = X.map(row => [1, ...row]);
            return math.multiply(X, this.coef_);
        }
    }

    class LogisticRegression {
        fit(X, y) {
            X = X.map(row => [1, ...row]);
            const sigmoid = z => 1 / (1 + Math.exp(-z));
            this.coef_ = Array(X[0].length).fill(0);
            const learningRate = 0.01;
            const iterations = 1000;

            for (let i = 0; i < iterations; i++) {
                const z = math.multiply(X, this.coef_);
                const h = z.map(sigmoid);
                const gradient = math.multiply(math.transpose(X), math.subtract(h, y));
                this.coef_ = math.subtract(this.coef_, math.multiply(learningRate, gradient));
            }
        }

        predict(X) {
            X = X.map(row => [1, ...row]);
            const z = math.multiply(X, this.coef_);
            const sigmoid = z => 1 / (1 + Math.exp(-z));
            const probs = z.map(sigmoid);
            return probs.map(p => (p >= 0.5 ? 1 : 0));
        }
    }

    class DecisionTreeClassifier {
        fit(X, y) {
            const buildTree = (X, y, depth = 0) => {
                if (depth === 5 || y.every(val => val === y[0])) {
                    return { value: y[0] };
                }

                let bestFeature, bestThreshold, bestGini = Infinity;
                for (let feature = 0; feature < X[0].length; feature++) {
                    const thresholds = [...new Set(X.map(row => row[feature]))];
                    for (const threshold of thresholds) {
                        const [leftX, leftY, rightX, rightY] = this.split(X, y, feature, threshold);
                        const gini = this.giniImpurity(leftY, rightY);
                        if (gini < bestGini) {
                            bestGini = gini;
                            bestFeature = feature;
                            bestThreshold = threshold;
                        }
                    }
                }

                const [leftX, leftY, rightX, rightY] = this.split(X, y, bestFeature, bestThreshold);
                return {
                    feature: bestFeature,
                    threshold: bestThreshold,
                    left: buildTree(leftX, leftY, depth + 1),
                    right: buildTree(rightX, rightY, depth + 1)
                };
            };

            this.tree = buildTree(X, y);
        }

        predict(X) {
            const traverse = (node, row) => {
                if (node.value !== undefined) {
                    return node.value;
                }
                if (row[node.feature] < node.threshold) {
                    return traverse(node.left, row);
                } else {
                    return traverse(node.right, row);
                }
            };

            return X.map(row => traverse(this.tree, row));
        }

        split(X, y, feature, threshold) {
            const leftX = [], leftY = [], rightX = [], rightY = [];
            for (let i = 0; i < X.length; i++) {
                if (X[i][feature] < threshold) {
                    leftX.push(X[i]);
                    leftY.push(y[i]);
                } else {
                    rightX.push(X[i]);
                    rightY.push(y[i]);
                }
            }
            return [leftX, leftY, rightX, rightY];
        }

        giniImpurity(leftY, rightY) {
            const leftSize = leftY.length;
            const rightSize = rightY.length;
            const totalSize = leftSize + rightSize;
            const gini = side => 1 - side.reduce((acc, val) => {
                const p = side.filter(v => v === val).length / side.length;
                return acc + p * p;
            }, 0);
            return (leftSize / totalSize) * gini(leftY) + (rightSize / totalSize) * gini(rightY);
        }
    }

    class SVMClassifier {
        fit(X, y) {
            const C = 1.0;
            const tol = 1e-3;
            const maxPasses = 5;
            const kernel = (x1, x2) => math.dot(x1, x2);

            this.alphas = Array(y.length).fill(0);
            this.b = 0;

            let passes = 0;
            while (passes < maxPasses) {
                let numChangedAlphas = 0;
                for (let i = 0; i < y.length; i++) {
                    const Ei = this.decisionFunction(X[i]) - y[i];
                    if ((y[i] * Ei < -tol && this.alphas[i] < C) || (y[i] * Ei > tol && this.alphas[i] > 0)) {
                        const j = this.randomIndex(i, y.length);
                        const Ej = this.decisionFunction(X[j]) - y[j];
                        const oldAi = this.alphas[i];
                        const oldAj = this.alphas[j];
                        const L = Math.max(0, oldAj - oldAi);
                        const H = Math.min(C, C + oldAj - oldAi);
                        if (L === H) continue;

                        const eta = 2 * kernel(X[i], X[j]) - kernel(X[i], X[i]) - kernel(X[j], X[j]);
                        if (eta >= 0) continue;

                        this.alphas[j] -= y[j] * (Ei - Ej) / eta;
                        this.alphas[j] = Math.min(H, Math.max(L, this.alphas[j]));
                        if (Math.abs(this.alphas[j] - oldAj) < tol) continue;

                        this.alphas[i] += y[i] * y[j] * (oldAj - this.alphas[j]);

                        const b1 = this.b - Ei - y[i] * (this.alphas[i] - oldAi) * kernel(X[i], X[i]) - y[j] * (this.alphas[j] - oldAj) * kernel(X[i], X[j]);
                        const b2 = this.b - Ej - y[i] * (this.alphas[i] - oldAi) * kernel(X[i], X[j]) - y[j] * (this.alphas[j] - oldAj) * kernel(X[j], X[j]);

                        if (0 < this.alphas[i] && this.alphas[i] < C) {
                            this.b = b1;
                        } else if (0 < this.alphas[j] && this.alphas[j] < C) {
                            this.b = b2;
                        } else {
                            this.b = (b1 + b2) / 2;
                        }

                        numChangedAlphas++;
                    }
                }

                if (numChangedAlphas === 0) {
                    passes++;
                } else {
                    passes = 0;
                }
            }
        }

        predict(X) {
            return X.map(row => (this.decisionFunction(row) >= 0 ? 1 : -1));
        }

        decisionFunction(x) {
            return math.dot(this.alphas, y.map((yi, i) => yi * math.dot(X[i], x))) + this.b;
        }

        randomIndex(exclude, length) {
            let index;
            do {
                index = Math.floor(Math.random() * length);
            } while (index === exclude);
            return index;
        }
    }

    class NaiveBayesClassifier {
        fit(X, y) {
            const n = X[0].length;
            this.classes = [...new Set(y)];
            this.classCounts = this.classes.map(c => y.filter(yi => yi === c).length);
            this.classProbs = this.classCounts.map(count => count / y.length);

            this.featureProbs = this.classes.map(c => {
                const Xc = X.filter((_, i) => y[i] === c);
                const probs = Array(n).fill(0).map(() => ({}));
                Xc.forEach(row => {
                    row.forEach((value, i) => {
                        if (!probs[i][value]) probs[i][value] = 0;
                        probs[i][value]++;
                    });
                });
                probs.forEach((prob, i) => {
                    Object.keys(prob).forEach(key => {
                        prob[key] /= Xc.length;
                    });
                });
                return probs;
            });
        }

        predict(X) {
            return X.map(row => {
                const probs = this.classes.map((c, i) => {
                    return this.classProbs[i] * row.reduce((prob, value, j) => {
                        return prob * (this.featureProbs[i][j][value] || 1e-9);
                    }, 1);
                });
                return this.classes[probs.indexOf(Math.max(...probs))];
            });
        }
    }

    class KNNClassifier {
        fit(X, y) {
            this.X = X;
            this.y = y;
        }

        predict(X) {
            const k = 5;
            return X.map(row => {
                const distances = this.X.map((x, i) => ({
                    index: i,
                    distance: math.distance(row, x)
                }));
                distances.sort((a, b) => a.distance - b.distance);
                const neighbors = distances.slice(0, k);
                const classes = neighbors.map(neighbor => this.y[neighbor.index]);
                const counts = {};
                classes.forEach(c => counts[c] = (counts[c] || 0) + 1);
                return +Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
            });
        }
    }

    class RandomForestClassifier {
        fit(X, y) {
            const nTrees = 10;
            const sampleSize = Math.floor(X.length / 2);
            this.trees = Array(nTrees).fill(0).map(() => {
                const sampleIndices = Array(sampleSize).fill(0).map(() => Math.floor(Math.random() * X.length));
                const sampleX = sampleIndices.map(i => X[i]);
                const sampleY = sampleIndices.map(i => y[i]);
                const tree = new DecisionTreeClassifier();
                tree.fit(sampleX, sampleY);
                return tree;
            });
        }

        predict(X) {
            const predictions = this.trees.map(tree => tree.predict(X));
            return X.map((_, i) => {
                const preds = predictions.map(pred => pred[i]);
                const counts = {};
                preds.forEach(p => counts[p] = (counts[p] || 0) + 1);
                return +Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
            });
        }
    }

    class GradientBoostingClassifier {
        fit(X, y) {
            const nEstimators = 100;
            const learningRate = 0.1;
            this.models = [];
            let residuals = y;

            for (let i = 0; i < nEstimators; i++) {
                const tree = new DecisionTreeClassifier();
                tree.fit(X, residuals);
                const preds = tree.predict(X);
                residuals = math.subtract(residuals, math.multiply(preds, learningRate));
                this.models.push(tree);
            }
        }

        predict(X) {
            return X.map(row => {
                const preds = this.models.map(tree => tree.predict([row])[0]);
                return math.sum(preds);
            });
        }
    }

    class AdaBoostClassifier {
        fit(X, y) {
            const nEstimators = 50;
            this.models = [];
            this.alphas = [];
            let weights = Array(y.length).fill(1 / y.length);

            for (let i = 0; i < nEstimators; i++) {
                const tree = new DecisionTreeClassifier();
                tree.fit(X, y, weights);
                const preds = tree.predict(X);
                const error = weights.reduce((sum, w, j) => sum + w * (preds[j] !== y[j]), 0);
                const alpha = 0.5 * Math.log((1 - error) / (error + 1e-10));
                weights = weights.map((w, j) => w * Math.exp(-alpha * y[j] * preds[j]));
                const sumWeights = math.sum(weights);
                weights = weights.map(w => w / sumWeights);
                this.models.push(tree);
                this.alphas.push(alpha);
            }
        }

        predict(X) {
            return X.map(row => {
                const weightedSum = this.models.reduce((sum, tree, i) => sum + this.alphas[i] * tree.predict([row])[0], 0);
                return weightedSum >= 0 ? 1 : -1;
            });
        }
    }

    function calculateMetrics(yTrue, yPred, problemType) {
        const tp = yTrue.filter((y, i) => y === 1 && yPred[i] === 1).length;
        const tn = yTrue.filter((y, i) => y === 0 && yPred[i] === 0).length;
        const fp = yTrue.filter((y, i) => y === 0 && yPred[i] === 1).length;
        const fn = yTrue.filter((y, i) => y === 1 && yPred[i] === 0).length;

        const accuracy = (tp + tn) / yTrue.length;
        const precision = tp / (tp + fp);
        const recall = tp / (tp + fn);
        const f1_score = 2 * (precision * recall) / (precision + recall);
        const specificity = tn / (tn + fp);
        const lr_plus = recall / (1 - specificity);
        const odds_ratio = (tp * tn) / (fp * fn);
        const prevalence_threshold = (Math.sqrt(tp + fn) - Math.sqrt(fp + tn)) / (tp + tn + fp + fn);

        const roc_auc = calculateAUC(yTrue, yPred);
        const roc_curve = rocCurve(yTrue, yPred);

        return {
            confusion_matrix: [[tn, fp], [fn, tp]],
            accuracy,
            precision,
            recall,
            f1_score,
            specificity,
            lr_plus,
            odds_ratio,
            prevalence_threshold,
            roc_auc,
            roc_curve
        };
    }

    function calculateAUC(yTrue, yPred) {
        const sorted = yPred.map((pred, i) => ({ pred, actual: yTrue[i] })).sort((a, b) => b.pred - a.pred);
        let tp = 0, fp = 0;
        let prev_tp = 0, prev_fp = 0;
        let auc = 0;

        sorted.forEach(({ pred, actual }) => {
            if (actual === 1) tp++;
            else fp++;

            if (prev_fp !== fp) {
                auc += (tp + prev_tp) * (fp - prev_fp) / 2;
                prev_tp = tp;
                prev_fp = fp;
            }
        });

        return auc / (tp * fp);
    }

    function rocCurve(yTrue, yPred) {
        const thresholds = [...new Set(yPred)].sort((a, b) => a - b);
        const rocPoints = thresholds.map(threshold => {
            const tp = yTrue.filter((y, i) => y === 1 && yPred[i] >= threshold).length;
            const fp = yTrue.filter((y, i) => y === 0 && yPred[i] >= threshold).length;
            const fn = yTrue.filter((y, i) => y === 1 && yPred[i] < threshold).length;
            const tn = yTrue.filter((y, i) => y === 0 && yPred[i] < threshold).length;

            const tpr = tp / (tp + fn);
            const fpr = fp / (fp + tn);

            return { tpr, fpr };
        });

        return rocPoints;
    }
</script>
</body>
</html>
