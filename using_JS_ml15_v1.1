<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Run Your ML Model</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: auto; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; }
        .form-group textarea, .form-group select, .form-group input { width: 100%; padding: 8px; }
        .form-group button { padding: 10px 20px; }
        .result, .status, .preview, .progress, .console { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
        .progress progress { width: 100%; }
        #chart { width: 100%; height: 400px; }
        .console { background-color: #000; color: #0f0; font-family: monospace; height: 200px; overflow-y: scroll; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@9.4.4/lib/browser/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/ml5@0.6.0/dist/ml5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
</head>
<body>

<div class="container">
    <h1>Run Your ML Model</h1>

    <div class="form-group">
        <label for="dataInput">Enter Data (CSV format: first row containing variable names, then variable values)</label>
        <textarea id="dataInput" rows="10" placeholder="Enter data in CSV format"></textarea>
    </div>

    <div class="form-group">
        <label for="fileInput">Upload Data File (CSV or Excel)</label>
        <input type="file" id="fileInput" accept=".csv, .xlsx, .xls" onchange="handleFileUpload(event)">
    </div>

    <div class="form-group">
        <button onclick="previewData()">Preview Data</button>
    </div>

    <div class="form-group">
        <label for="dependentVar">Select Dependent Variable</label>
        <select id="dependentVar"></select>
    </div>

    <div class="form-group">
        <label for="independentVars">Select Independent Variables</label>
        <select id="independentVars" multiple></select>
    </div>

    <div class="form-group">
        <label for="problemType">Select Problem Type</label>
        <select id="problemType">
            <option value="classification">Classification</option>
            <option value="regression">Regression</option>
        </select>
    </div>

    <div class="form-group">
        <button onclick="runModel()">Run Model</button>
    </div>

    <div class="progress">
        <progress id="progressBar" value="0" max="100"></progress>
        <span id="progressText">0%</span>
    </div>

    <div class="status" id="status"></div>
    <div class="console" id="console"></div>
    <div class="preview" id="preview"></div>
    <div class="result" id="result"></div>
    <canvas id="chart"></canvas>
</div>

<script>
    let uploadedData = '';
    let currentModel = null;

    function previewData() {
        const dataInput = document.getElementById('dataInput').value;
        if (dataInput.trim() !== '') {
            uploadedData = dataInput;
        }
        displayPreview(uploadedData);
    }

    function handleFileUpload(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        const fileType = file.type;

        reader.onload = function(e) {
            try {
                const content = e.target.result;

                if (fileType === 'text/csv' || file.name.endsWith('.csv')) {
                    const parsedData = Papa.parse(content, { header: false }).data;
                    uploadedData = parsedData.map(row => row.join(',')).join('\n');
                } else if (fileType.includes('spreadsheetml') || file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const workbook = XLSX.read(content, { type: 'binary' });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    uploadedData = json.map(row => row.join(',')).join('\n');
                }
                document.getElementById('dataInput').value = uploadedData;
                previewData();
            } catch (error) {
                logToConsole(`Error during file upload: ${error.message}`);
            }
        };

        if (fileType === 'text/csv' || file.name.endsWith('.csv')) {
            reader.readAsText(file);
        } else if (fileType.includes('spreadsheetml') || file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
            reader.readAsBinaryString(file);
        }
    }

    function displayPreview(content) {
        const rows = content.split('\n');
        const previewDiv = document.getElementById('preview');
        previewDiv.innerHTML = `<h2>Preview of Data (First 5 Rows)</h2>`;
        rows.slice(0, 5).forEach(row => {
            previewDiv.innerHTML += `<pre>${row}</pre>`;
        });

        const columns = rows[0].split(',');
        populateDropdowns(columns);
    }

    function populateDropdowns(columns) {
        const dependentVar = document.getElementById('dependentVar');
        const independentVars = document.getElementById('independentVars');
        dependentVar.innerHTML = '';
        independentVars.innerHTML = '';

        columns.forEach(col => {
            const option = document.createElement('option');
            option.value = col;
            option.textContent = col;
            dependentVar.appendChild(option);

            const multiOption = option.cloneNode(true);
            independentVars.appendChild(multiOption);
        });
    }

    function updateProgress(progress) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        progressBar.value = progress;
        progressText.textContent = `${progress}%`;
    }

    function logToConsole(message) {
        const consoleDiv = document.getElementById('console');
        consoleDiv.innerHTML += `<div>${message}</div>`;
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    function runModel() {
        const statusDiv = document.getElementById('status');
        const dependentVar = document.getElementById('dependentVar').value;
        const independentVars = Array.from(document.getElementById('independentVars').selectedOptions).map(opt => opt.value);
        const problemType = document.getElementById('problemType').value;

        statusDiv.textContent = `Running model...`;
        logToConsole(`Starting model run...`);
        updateProgress(0);

        try {
            const dataInput = document.getElementById('dataInput').value;
            const rows = dataInput.split('\n').map(row => row.split(','));
            const headers = rows[0];
            const data = rows.slice(1).map(row => row.map(cell => parseFloat(cell)));

            const depIndex = headers.indexOf(dependentVar);
            const indIndexes = independentVars.map(v => headers.indexOf(v));

            if (depIndex === -1 || indIndexes.includes(-1)) {
                throw new Error("Selected variable names do not match with the data headers.");
            }

            const X = data.map(row => indIndexes.map(i => row[i]));
            const y = data.map(row => row[depIndex]);

            logToConsole(`Data successfully parsed. Rows: ${data.length}, Columns: ${headers.length}`);

            if (currentModel) {
                currentModel = null;
            }

            if (problemType === 'regression') {
                runRegressionModel(X, y);
            } else {
                runClassificationModel(X, y);
            }
        } catch (error) {
            logToConsole(`Error: ${error.message}`);
            statusDiv.textContent = 'Error encountered. Check the console for details.';
        }
    }

    function runRegressionModel(X, y) {
        currentModel = ml5.neuralNetwork({ task: 'regression', debug: true });

        X.forEach((input, index) => {
            currentModel.addData(input, [y[index]]);
        });

        currentModel.normalizeData();

        currentModel.train({ epochs: 50 }, (error) => {
            if (error) {
                logToConsole(`Training error: ${error}`);
                return;
            }
            logToConsole(`Model trained successfully`);
            makePredictions();
        }, (epoch, loss) => {
            updateProgress(epoch * 100 / 50);
            logToConsole(`Epoch ${epoch + 1}: loss = ${loss.loss}`);
        });

        function makePredictions() {
            const predictions = X.map(input => new Promise((resolve) => {
                currentModel.predict(input, (err, results) => {
                    if (err) {
                        logToConsole(`Prediction error: ${err}`);
                        resolve(null);
                    } else {
                        resolve(results[0].value);
                    }
                });
            }));

            Promise.all(predictions).then((yPred) => {
                const result = calculateMetrics(y, yPred, 'regression');
                displayResult(result, 'Neural Network Regression');
                updateProgress(100);
                document.getElementById('status').textContent = 'Model run successfully';
                logToConsole(`Model run completed successfully`);
            });
        }
    }

    function runClassificationModel(X, y) {
        currentModel = ml5.neuralNetwork({ task: 'classification', debug: true });

        X.forEach((input, index) => {
            currentModel.addData(input, [y[index]]);
        });

        currentModel.normalizeData();

        currentModel.train({ epochs: 50 }, (error) => {
            if (error) {
                logToConsole(`Training error: ${error}`);
                return;
            }
            logToConsole(`Model trained successfully`);
            makePredictions();
        }, (epoch, loss) => {
            updateProgress(epoch * 100 / 50);
            logToConsole(`Epoch ${epoch + 1}: loss = ${loss.loss}`);
        });

        function makePredictions() {
            const predictions = X.map(input => new Promise((resolve) => {
                currentModel.classify(input, (err, results) => {
                    if (err) {
                        logToConsole(`Prediction error: ${err}`);
                        resolve(null);
                    } else {
                        resolve(results[0].label);
                    }
                });
            }));

            Promise.all(predictions).then((yPred) => {
                const result = calculateMetrics(y, yPred, 'classification');
                displayResult(result, 'Neural Network Classification');
                updateProgress(100);
                document.getElementById('status').textContent = 'Model run successfully';
                logToConsole(`Model run completed successfully`);
            });
        }
    }

    function calculateMetrics(y, yPred, problemType) {
        if (problemType === 'regression') {
            const mse = math.mean(y.map((val, i) => Math.pow(val - yPred[i], 2)));
            const rmse = Math.sqrt(mse);
            const mae = math.mean(y.map((val, i) => Math.abs(val - yPred[i])));
            return {
                mse,
                rmse,
                mae
            };
        } else {
            let tp = 0, tn = 0, fp = 0, fn = 0;
            for (let i = 0; i < y.length; i++) {
                if (y[i] === 1 && yPred[i] == 1) tp++;
                if (y[i] === 0 && yPred[i] == 0) tn++;
                if (y[i] === 0 && yPred[i] == 1) fp++;
                if (y[i] === 1 && yPred[i] == 0) fn++;
            }

            const accuracy = (tp + tn) / (tp + tn + fp + fn);
            const precision = tp / (tp + fp);
            const recall = tp / (tp + fn);
            const f1Score = 2 * (precision * recall) / (precision + recall);
            const specificity = tn / (tn + fp);
            const lrPlus = recall / (1 - specificity);
            const oddsRatio = (tp * tn) / (fp * fn);
            const prevalenceThreshold = (Math.sqrt(tp + fn) - Math.sqrt(fp + tn)) / (tp + tn + fp + fn);

            return {
                confusion_matrix: [[tp, fp], [fn, tn]],
                accuracy,
                precision,
                recall,
                f1_score: f1Score,
                specificity,
                lr_plus: lrPlus,
                odds_ratio: oddsRatio,
                prevalence_threshold: prevalenceThreshold,
                roc_curve: calculateROCCurve(y, yPred)
            };
        }
    }

    function calculateROCCurve(y, yPred) {
        const thresholds = [...new Set(yPred)].sort((a, b) => a - b);
        const rocCurve = thresholds.map(threshold => {
            let tp = 0, tn = 0, fp = 0, fn = 0;
            y.forEach((actual, index) => {
                const predicted = yPred[index] >= threshold ? 1 : 0;
                if (actual === 1 && predicted === 1) tp++;
                if (actual === 0 && predicted === 0) tn++;
                if (actual === 0 && predicted === 1) fp++;
                if (actual === 1 && predicted === 0) fn++;
            });
            const tpr = tp / (tp + fn);
            const fpr = fp / (fp + tn);
            return { tpr, fpr };
        });
        return rocCurve;
    }

    function displayResult(result, modelName) {
        const resultDiv = document.getElementById('result');
        resultDiv.innerHTML += `
            <h2>${modelName} Results</h2>
            <pre>${JSON.stringify(result, null, 2)}</pre>
            <h3>Evaluation Metrics</h3>
        `;
        if (result.confusion_matrix) {
            resultDiv.innerHTML += `
                <p><b>Confusion Matrix:</b> [[${result.confusion_matrix[0][0]}, ${result.confusion_matrix[0][1]}], [${result.confusion_matrix[1][0]}, ${result.confusion_matrix[1][1]}]]</p>
                <p><b>Accuracy:</b> ${result.accuracy}</p>
                <p><b>Precision:</b> ${result.precision}</p>
                <p><b>Recall:</b> ${result.recall}</p>
                <p><b>F1 Score:</b> ${result.f1_score}</p>
                <p><b>Specificity:</b> ${result.specificity}</p>
                <p><b>LR+:</b> ${result.lr_plus}</p>
                <p><b>Odds Ratio:</b> ${result.odds_ratio}</p>
                <p><b>Prevalence Threshold:</b> ${result.prevalence_threshold}</p>
            `;
            displayGraph(result.roc_curve, modelName);
        } else {
            resultDiv.innerHTML += `
                <p><b>MSE:</b> ${result.mse}</p>
                <p><b>RMSE:</b> ${result.rmse}</p>
                <p><b>MAE:</b> ${result.mae}</p>
            `;
        }
    }

    function displayGraph(rocCurve, modelName) {
        const ctx = document.getElementById('chart').getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: rocCurve.map(point => point.fpr),
                datasets: [{
                    label: `${modelName} ROC Curve`,
                    data: rocCurve.map(point => ({ x: point.fpr, y: point.tpr })),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom'
                    }
                }
            }
        });
    }
</script>
</body>
</html>
